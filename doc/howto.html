<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <title>Brumba HowTo</title>
  </head>
  <body style=" margin-left: 70px; max-width: 1000px;" lang="en-US">
    <h2 align="center"> Brumba IDE HowTo</h2>
    <p style="margin-bottom: 0cm" align="center">by Dan Parnete</p>
    <p style="margin-bottom: 0cm" align="right">updated: 10 August 2020</p>
    <p><br>
      <br>
    </p>
    <p>Run your Brumba server on <a href="https://localhost:3090/">https://localhost:3090</a>
      to avoid password annoyance (no user check).<br>
      Open IDE from <a href="http://localhost:3090/ide">http://localhost:3090/ide</a></p>
    <p><b>Save</b>: Use <i>save</i> button in the toolbar. <br>
      <b>Delete</b>: Use <i>delete</i> button in the toolbar. </p>
    <p><b>Records list</b>: If the form/page has to display the records list,
      use the <i>list</i> toolbar button.</p>
    <p><br>
      <br>
    </p>
    <h4>Forms</h4>
    <p><b>Create</b>: <i>Tools</i> menu. Write fields name (comma separated).
      Field name should not include spaces or special characters, except
      underscore. Click <i>New Form</i> or <i>New Grid</i>. <br>
      <b>Properties button</b>: Open it from <i>Properties</i> toolbat button.
      Click on form/field/label to change it's properties. <br>
      <b>Container borders</b>: Use CTRL+B, or toolbar <i>borders</i> button,
      to toggle container borders.<br>
      <b>Select fields</b>: click on the field, or CTRL+click to toggle
      selection. <br>
      <b>Move field</b>: by dragging it on the bottom of the same container, or
      in another container. You cam also drop it over another field to put it on
      the same row.<br>
      <b>Resize selected field</b>: SHIFT+arrow left/right keys, or change <i>width</i>
      % in <i>Properties.</i><br>
      <b>Add fields</b>: From the <i>Tool</i> menu, write fields name, click
      the mouse on the container you want to add to, then click <i>Add Fields</i>
      menu. For adding just one element, use right click to the desired
      container, choose the element to add from the context menu.<br>
      <b>Events button</b>: write form specific script.<br>
      <b>CSS button</b>: write form specific CSS.<br>
      <b>HTM buttonL</b>: view/modify form’s html. Pay attention, the grid is
      not saved as seen, but only the form tag without it’s innerHTML.</p>
    <h4>Pages</h4>
    <p><b>Create</b>: <i>Tools / New Page</i> menu. Use <i>Split horizontal</i>
      or <i>Split vertical</i> from context menu to divide in more parts. Use <i>Add
        column</i> to add more containers horizontaly. Select container and use
      SHIFT+arrow left/right to resize it.<br>
      <b>Set forms</b>: <i>Set form</i> from context menu on each container. <br>
      <b>Tabs</b>: Context menu <i>Add Tab</i> in container you want to add
      tabbed forms. Each tab presents a container that can be divided further.
      Right click on tab zone to <i>Add/Remove</i> tabs. Rename tab from <i>Properties</i>.<br>
      <br>
      <br>
    </p>
    <h4>Reports</h4>
    <p><b>Create</b>: <i>Tools / New Report</i> menu. Defaults to portrait, can
      switch to landscape from <i>Properties.</i> In report everything is fixed
      size, fixed position. Select band with DblClick and resize with
      SHIFT+arrow up/down. Add label, field, image from context menu.<br>
      <b>Group</b>: Add <i>group</i> band from context menu. <br>
      <b>Move</b>: Move elements with CTRL+arrow.<br>
      <b>Resize</b>: Resize elements with SHIFT+arrow.<br>
      <b>Multi select</b>: CTRL+mouse drag over.<br>
      <br>
      <br>
    </p>
    <h4>Menu</h4>
    <p><b>Create/Modify</b>: Use <i>MENU</i> menu. The menu is a simple text,
      TAB indentation is the level separator. Single forms are called as <i>forms.FormName</i>
      , pages as <i>pages.PageName</i> ex.: </p>
    <ul>
      <li>
        <p style="margin-bottom: 0cm"><code>“</code><code>Header 1” </code> </p>
        <ul>
          <li>
            <p style="margin-bottom: 0cm"><code>“</code><code>Sub level 1” </code>
            </p>
            <ul>
              <li>
                <p style="margin-bottom: 0cm"><code>“</code><code>Item 1”
                    forms.Form1 </code> </p>
              </li>
              <li>
                <p style="margin-bottom: 0cm"><code>“</code><code>Item 2”
                    pages.Page2 </code> </p>
              </li>
            </ul>
          </li>
          <li>
            <p style="margin-bottom: 0cm"><code>“</code><code>Item 3”
                forms.Form3 </code> </p>
          </li>
          <li>
            <p style="margin-bottom: 0cm"><code>"Options"
                forms._options:menuid:menusort </code> </p>
          </li>
        </ul>
      </li>
      <li>
        <p><code>“</code><code>Item 4” pages.Page4 </code> </p>
      </li>
    </ul>
    <p><br>
      <br>
    </p>
    <h4>Forms query</h4>
    <p>Query has the format: <br>
      <code>{ coll: 'collectionName', fields: 'field1, field2, …', where:
        {condition}, sort: {field1: 1, field2:-1} }</code> <br>
      Where condition has the <a href="http://docs.mongodb.org/manual/reference/operator/query/">MongoDb
        find format</a>. Sort 1 is ascending, -1 descending. <br>
      If the form is the main plain form, <i>query</i> is for the records list.
      In this case, <i>fields</i> defines the list columns: <code>fieldName :
        width : headerText , …</code> <br>
      If the query has <code>findone: true </code>option, only one record will
      be returned, no list neaded.<br>
      A grid could display an array field of it's master (embedded array in a
      document), and the query will be <code>{ field: 'arrayFieldName',
        reorder: {field1: 1, field2:-1} }</code> (see <i>Patient_visit</i> form
      in the demo application), where field could be ‘level1.level2.level3’ for
      multilevel embedded array (see Patient_prescription form).<br>
      A grid could display the concatenation of an array field for the selected
      documents, and the query will be <code>{ concat: 'arrayFieldName', add:
        'field1,fields2,...' }</code> (see <i>Patient_all</i> form in the demo
      application). Add master fields to each record of the result with "add"
      parameter. <br>
      If the form is just an extension of the main form (record divided in more
      tabpages), use an empty query <code>{}</code> (see <i>Patients_address</i>
      form in the demo application). </p>
    <p><br>
      <br>
    </p>
    <h4>Select query</h4>
    <p><i>query</i> could be a database query (as for the form) or a JSON array
      (fixed options) <br>
      <code>[ {_id:.., _txt:..}, … ]</code> (see Drugs_form <i>form</i> field
      in the demo application). <br>
      <i>Fields</i>: the first field is the select value, the others separated
      by ' - ' creates the text. To use just a space as separator, start the
      field name with '+' : <code>_id,name,+surname</code></p>
    <p><br>
      <br>
    </p>
    <h4>Autocomplete query</h4>
    <p><span style="font-variant: normal"><span style="font-style: normal">Same
          as select, with an</span></span> <code>extra : 'filed1,field2,...'</code>
      property used for displaying additional readonly data from the
      autocomplete record in the current form. The form must have this fields
      set as disable, or at least readonly.</p>
    <br>
    <h4>Events</h4>
    <p>Open events dialog from <i>Events</i> toolbar button. It is always
      relative to the current form. <br>
      Brumba defines this form events: <br>
      - <i>new</i> (new button, for some document initialization) <br>
      - <i>save</i> (before save, to check values or alter form.modif) <br>
      - <i>delete</i> (before delete, to check and validate) <br>
      - <i>retrieve</i> (after retrieve, to alter dataset before display) <br>
      - <i>display</i> (after form display data) <br>
      - <i>rowselected</i> (for tabular forms) <br>
      An event can return <i>true</i> as a STOP message, to prevent the normal
      behavior. Inside the <i>open</i> event you can write all other component
      events: </p>
    <p><br>
      <br>
    </p>
    <h4>Scripts</h4>
    <p>Open it from <i>Scripts</i> menu, or create a new script from Tools/New
      script. . <br>
      Call a server function from client with:</p>
    <p><code>{ script: 'scriptName.functionName' [,args: {...}]}</code></p>
    This syntax can be used as form/select query, or as a direct call from an
    event:
    <p><code>remote(query)</code></p>
    <p>Scripts are cached and loaded from brumba/scripts/appName directory.</p>
    If you have a lot of code to write into events, it's a better practice to
    write it in a script and load it dynamically from the event with:<br>
    <code>clientScript(scriptName, cs =&gt; {cs.yourFunc()})</code>
    <p></p>
    <h4><br>
      <br>
    </h4>
    <h4>Database triggers</h4>
    <p style="background-color: white;">There is a special server script called
      <code>triggers</code>. Here you can define triggers of type: <code>beforeSave,
        afterSave, beforeDelete, afterDelete</code> for any collection. The
      trigger function must be named <code>collection_triggerName</code>.
      Example of <code>beforeSave</code> on Prescriptions collection:</p>
    <p style="margin-left: 1.07cm; margin-bottom: 0cm"><code>import { err } from
        '/lib/common.js'<br>
        <br>
        export const Prescriptions_beforeSave = (par, callback, data) {<br>
        &nbsp;&nbsp;&nbsp; ...<br>
        &nbsp;&nbsp;&nbsp; callback({err: err.trig})<br>
        }</code></p>
    <p style="margin-bottom: 0cm"><br>
      If a <code>before</code> trigger returns <code>{err: U.err.trig}</code>
      the transaction will be blocked. <br>
      <code>after</code> triggers will receive the transaction result in <code>par.res</code>
      and the original state of the modified data in <code>par.before</code></p>
  </body>
</html>
